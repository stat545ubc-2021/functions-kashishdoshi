---
title: "Function"
author: "Kashish Doshi"
date: "01/11/2021"
Roxygen: list(markdown = TRUE)
output: github_document
---


```{r}

suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(testthat))
suppressPackageStartupMessages(library(datateachr))

```

## find_mean

The goal of this function was to build a specific workflow around dplyr::group_by() and dplyr::mutate(). I wanted to build this function because in the milstone asignments in STAT 545A I used this partiular workflow numerous times and would have helped to have a function that could return this output with one line instead of 3. 
```{r find_mean}

#' find_mean function
#' 
#' @title Find mean of columns according to groups and add it to original tibble.
#' @name find_mean
#' @usage find_mean(tib, col_name, group_col_name)
#' @description Add a mean column to data-frame after grouping by another column. The new mean column name will add a "mean." prefix to the
#'original column name ("mean.col_name"). This function uses the mutate [dplyr::mutate()] function and group_by [dplyr::group_by()] from the dplyr package.
#' 
#' @param tib A tibble. Since the input should be a tibble I named it "tib"
#' @param col_name A column name to find mean of. To make it evident I named it "col_name". Function will remove NA from this column
#' @param group_col_name Optional parameter. A column name. If provided, data-set will be grouped by this column before finding mean. Since the data is going to be grouped according to this I named it "group_col_name". Function will not remove any NA from this column.
#' 
#' @return A tibble
#' @export
#' @md

find_mean = function(tib, col_name, group_col_name) {
  calculations = dplyr::summarise(tib,
                                  is_numeric = is.numeric({{ col_name }}),
                                  class = class({{ col_name }}))
  if (!calculations$is_numeric) {
    stop("Selected column is not numeric. Column is ", calculations$class)
  }
  if (missing(group_col_name)) {
    mean_tib <- dplyr::mutate(tib, "mean.{{ col_name }}" := mean({{ col_name }}, na.rm = TRUE))
    } else {
      mean_tib <- tib %>% 
        dplyr::group_by({{ group_col_name }}) %>%
        dplyr::mutate("mean.{{ col_name }}" := mean({{ col_name }}, na.rm = TRUE))
    }
  }

```

### Examples 


#### 1. Test without optional parameters
```{r}
#Example of finding mean without optional input

gap_lfExp_mean = find_mean(gapminder, lifeExp)
print(gap_lfExp_mean)

```
#### 2. Test with optional parameters
```{r}
#Example of finding mean with optional input

lifeExp_coun_mean = find_mean(gapminder, lifeExp, country)
print(lifeExp_coun_mean)
```
#### 3. Test with non-expected input parameter
```{r error=TRUE}
#Example of error

find_mean(gapminder, country, continent)

```
### Formally testing the function

Here I have conducted 5 tests that can demonstrate the validity and usability of the function.
```{r}
test1 = mutate(gapminder, mean.lifeExp = mean(lifeExp, na.rm = TRUE))
test_that("Test find_mean with input Vector that has no NAs and no optional argument", 
          expect_equal(find_mean(gapminder, lifeExp), test1))

test2 = mutate(vancouver_trees, mean.latitude = mean(latitude, na.rm= TRUE))
test_that("Test find_mean with input Vector that has NAs and no optional argument", 
          expect_equal(find_mean(vancouver_trees, latitude), test2))

test3 = vancouver_trees %>%
  group_by(cultivar_name) %>%
  mutate(mean.diameter = mean(diameter, na.rm=TRUE))
test_that("Test find_mean with input Vector that has NAs and an optional argument", 
          expect_equal(find_mean(vancouver_trees, diameter, cultivar_name), test3))

test4 = mutate(vancouver_trees, new_col = NA)
test_that("Test find_mean with input Vector that ONLY has NAs and an optional argument", 
          expect_error(find_mean(test4, new_col, cultivar_name)))

test_that("Test find_mean with input Vector of non-numeric type and an optional argument", 
          expect_error(find_mean(test4, species_name, cultivar_name)))

```

